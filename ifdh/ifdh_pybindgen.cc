/* This file was generated by PyBindGen 0.0.0.0 */
#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stddef.h>


#if PY_VERSION_HEX < 0x020400F0

#define PyEval_ThreadsInitialized() 1

#define Py_CLEAR(op)				\
        do {                            	\
                if (op) {			\
                        PyObject *tmp = (PyObject *)(op);	\
                        (op) = NULL;		\
                        Py_DECREF(tmp);		\
                }				\
        } while (0)


#define Py_VISIT(op)							\
        do { 								\
                if (op) {						\
                        int vret = visit((PyObject *)(op), arg);	\
                        if (vret)					\
                                return vret;				\
                }							\
        } while (0)

#endif



#if PY_VERSION_HEX < 0x020500F0

typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intobjargproc ssizeobjargproc;

#endif


#ifndef PyVarObject_HEAD_INIT
#define PyVarObject_HEAD_INIT(type, size) \
        PyObject_HEAD_INIT(type) size,
#endif


#if PY_VERSION_HEX >= 0x03000000
#if PY_VERSION_HEX >= 0x03050000
typedef PyAsyncMethods* cmpfunc;
#else
typedef void* cmpfunc;
#endif
#define PyCObject_FromVoidPtr(a, b) PyCapsule_New(a, NULL, b)
#define PyCObject_AsVoidPtr(a) PyCapsule_GetPointer(a, NULL)
#define PyString_FromString(a) PyBytes_FromString(a)
#define Py_TPFLAGS_CHECKTYPES 0 /* this flag doesn't exist in python 3 */
#endif


#if     __GNUC__ > 2
# define PYBINDGEN_UNUSED(param) param __attribute__((__unused__))
#elif     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
# define PYBINDGEN_UNUSED(param) __attribute__((__unused__)) param
#else
# define PYBINDGEN_UNUSED(param) param
#endif  /* !__GNUC__ */

#ifndef _PyBindGenWrapperFlags_defined_
#define _PyBindGenWrapperFlags_defined_
typedef enum _PyBindGenWrapperFlags {
   PYBINDGEN_WRAPPER_FLAG_NONE = 0,
   PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED = (1<<0),
} PyBindGenWrapperFlags;
#endif


#include "ifdh.h"
/* --- forward declarations --- */


typedef struct {
    PyObject_HEAD
    ifdh_ns::ifdh_lss_pair *obj;
    PyBindGenWrapperFlags flags:8;
} PyIfdh_nsIfdh_lss_pair;


extern PyTypeObject PyIfdh_nsIfdh_lss_pair_Type;


typedef struct {
    PyObject_HEAD
    ifdh_ns::ifdh *obj;
    PyBindGenWrapperFlags flags:8;
} PyIfdh_nsIfdh;


extern PyTypeObject PyIfdh_nsIfdh_Type;


typedef struct {
    PyObject_HEAD
    std::vector<ifdh_lss_pair> *obj;
} Pystd__vector__lt__ifdh_lss_pair__gt__;


typedef struct {
    PyObject_HEAD
    Pystd__vector__lt__ifdh_lss_pair__gt__ *container;
    std::vector<ifdh_lss_pair>::iterator *iterator;
} Pystd__vector__lt__ifdh_lss_pair__gt__Iter;


extern PyTypeObject Pystd__vector__lt__ifdh_lss_pair__gt___Type;
extern PyTypeObject Pystd__vector__lt__ifdh_lss_pair__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___ifdh_lss_pair___gt__(PyObject *arg, std::vector<ifdh_lss_pair> *container);

typedef struct {
    PyObject_HEAD
    std::vector<std::string> *obj;
} Pystd__vector__lt__std__string__gt__;


typedef struct {
    PyObject_HEAD
    Pystd__vector__lt__std__string__gt__ *container;
    std::vector<std::string>::iterator *iterator;
} Pystd__vector__lt__std__string__gt__Iter;


extern PyTypeObject Pystd__vector__lt__std__string__gt___Type;
extern PyTypeObject Pystd__vector__lt__std__string__gt__Iter_Type;

int _wrap_convert_py2c__std__vector__lt___std__string___gt__(PyObject *arg, std::vector<std::string> *container);

typedef struct {
    PyObject_HEAD
    std::map<std::string,std::vector<std::string> > *obj;
} Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__;


typedef struct {
    PyObject_HEAD
    Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__ *container;
    std::map<std::string,std::vector<std::string> >::iterator *iterator;
} Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter;


extern PyTypeObject Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt___Type;
extern PyTypeObject Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter_Type;

int _wrap_convert_py2c__std__map__lt___std__string__std__vector__lt___std__string___gt_____gt__(PyObject *arg, std::map<std::string,std::vector<std::string> > *container);

extern PyTypeObject *Pystd__logic_error_Type;


int _wrap_convert_py2c__ifdh_lss_pair(PyObject *value, ifdh_lss_pair *address);


int _wrap_convert_py2c__std__string(PyObject *value, std::string *address);

static PyMethodDef ifdh_functions[] = {
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */


static PyObject* _wrap_PyIfdh_nsIfdh_lss_pair__get_first(PyIfdh_nsIfdh_lss_pair *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "s#", (self->obj->first).c_str(), (self->obj->first).size());
    return py_retval;
}
static int _wrap_PyIfdh_nsIfdh_lss_pair__set_first(PyIfdh_nsIfdh_lss_pair *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;
    const char *retval_ptr;
    Py_ssize_t retval_len;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "s#", &retval_ptr, &retval_len)) {
        Py_DECREF(py_retval);
        return -1;
    }
    self->obj->first = std::string(retval_ptr, retval_len);
    Py_DECREF(py_retval);
    return 0;
}
static PyObject* _wrap_PyIfdh_nsIfdh_lss_pair__get_second(PyIfdh_nsIfdh_lss_pair *self, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "l", self->obj->second);
    return py_retval;
}
static int _wrap_PyIfdh_nsIfdh_lss_pair__set_second(PyIfdh_nsIfdh_lss_pair *self, PyObject *value, void * PYBINDGEN_UNUSED(closure))
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "l", &self->obj->second)) {
        Py_DECREF(py_retval);
        return -1;
    }
    Py_DECREF(py_retval);
    return 0;
}
static PyGetSetDef PyIfdh_nsIfdh_lss_pair__getsets[] = {
    {
        (char*) "first", /* attribute name */
        (getter) _wrap_PyIfdh_nsIfdh_lss_pair__get_first, /* C function to get the attribute */
        (setter) _wrap_PyIfdh_nsIfdh_lss_pair__set_first, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    {
        (char*) "second", /* attribute name */
        (getter) _wrap_PyIfdh_nsIfdh_lss_pair__get_second, /* C function to get the attribute */
        (setter) _wrap_PyIfdh_nsIfdh_lss_pair__set_second, /* C function to set the attribute */
        NULL, /* optional doc string */
        NULL /* optional additional data for getter and setter */
    },
    { NULL, NULL, NULL, NULL, NULL }
};


static int
_wrap_PyIfdh_nsIfdh_lss_pair__tp_init__0(PyIfdh_nsIfdh_lss_pair *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ifdh_ns::ifdh_lss_pair();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyIfdh_nsIfdh_lss_pair__tp_init__1(PyIfdh_nsIfdh_lss_pair *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyIfdh_nsIfdh_lss_pair *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyIfdh_nsIfdh_lss_pair_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new ifdh_ns::ifdh_lss_pair(*((PyIfdh_nsIfdh_lss_pair *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyIfdh_nsIfdh_lss_pair__tp_init(PyIfdh_nsIfdh_lss_pair *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyIfdh_nsIfdh_lss_pair__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyIfdh_nsIfdh_lss_pair__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


static PyObject*
_wrap_PyIfdh_nsIfdh_lss_pair__copy__(PyIfdh_nsIfdh_lss_pair *self)
{

    PyIfdh_nsIfdh_lss_pair *py_copy;
    py_copy = PyObject_New(PyIfdh_nsIfdh_lss_pair, &PyIfdh_nsIfdh_lss_pair_Type);
    py_copy->obj = new ifdh_ns::ifdh_lss_pair(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyIfdh_nsIfdh_lss_pair_methods[] = {
    {(char *) "__copy__", (PyCFunction) _wrap_PyIfdh_nsIfdh_lss_pair__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyIfdh_nsIfdh_lss_pair__tp_dealloc(PyIfdh_nsIfdh_lss_pair *self)
{
        ifdh_ns::ifdh_lss_pair *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

PyTypeObject PyIfdh_nsIfdh_lss_pair_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "ifdh.Ifdh_lss_pair",            /* tp_name */
    sizeof(PyIfdh_nsIfdh_lss_pair),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyIfdh_nsIfdh_lss_pair__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
    NULL,
#else
    (cmpfunc)NULL,           /* tp_compare */
#endif
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    "ifdh_lss_pair(ctor_arg)\nifdh_lss_pair()",                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyIfdh_nsIfdh_lss_pair_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    PyIfdh_nsIfdh_lss_pair__getsets,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyIfdh_nsIfdh_lss_pair__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static int
_wrap_PyIfdh_nsIfdh__tp_init(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    const char *baseuri = NULL;
    Py_ssize_t baseuri_len;
    const char *keywords[] = {"baseuri", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|s#", (char **) keywords, &baseuri, &baseuri_len)) {
        return -1;
    }
    self->obj = new ifdh_ns::ifdh((baseuri ? std::string(baseuri, baseuri_len) : ""));
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}


PyObject *
_wrap_PyIfdh_nsIfdh_set_debug(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *s;
    Py_ssize_t s_len;
    const char *keywords[] = {"s", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &s, &s_len)) {
        return NULL;
    }
    try
    {
        self->obj->set_debug(std::string(s, s_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_set_base_uri(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *baseuri;
    Py_ssize_t baseuri_len;
    const char *keywords[] = {"baseuri", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &baseuri, &baseuri_len)) {
        return NULL;
    }
    try
    {
        self->obj->set_base_uri(std::string(baseuri, baseuri_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_cp(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    std::vector<std::string> args_value;
    const char *keywords[] = {"args", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&", (char **) keywords, _wrap_convert_py2c__std__vector__lt___std__string___gt__, &args_value)) {
        return NULL;
    }
    try
    {
        retval = self->obj->cp(args_value);
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_fetchInput(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *src_uri;
    Py_ssize_t src_uri_len;
    const char *keywords[] = {"src_uri", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &src_uri, &src_uri_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->fetchInput(std::string(src_uri, src_uri_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_localPath(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *src_uri;
    Py_ssize_t src_uri_len;
    const char *keywords[] = {"src_uri", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &src_uri, &src_uri_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->localPath(std::string(src_uri, src_uri_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_addOutputFile(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *filename;
    Py_ssize_t filename_len;
    const char *keywords[] = {"filename", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &filename, &filename_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->addOutputFile(std::string(filename, filename_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_copyBackOutput(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *dest_dir;
    Py_ssize_t dest_dir_len;
    int hash = 0;
    const char *keywords[] = {"dest_dir", "hash", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|i", (char **) keywords, &dest_dir, &dest_dir_len, &hash)) {
        return NULL;
    }
    try
    {
        retval = self->obj->copyBackOutput(std::string(dest_dir, dest_dir_len), hash);
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_log(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *message;
    Py_ssize_t message_len;
    const char *keywords[] = {"message", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &message, &message_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->log(std::string(message, message_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_enterState(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *state;
    Py_ssize_t state_len;
    const char *keywords[] = {"state", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &state, &state_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->enterState(std::string(state, state_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_leaveState(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *state;
    Py_ssize_t state_len;
    const char *keywords[] = {"state", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &state, &state_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->leaveState(std::string(state, state_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_createDefinition(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *name;
    Py_ssize_t name_len;
    const char *dims;
    Py_ssize_t dims_len;
    const char *user;
    Py_ssize_t user_len;
    const char *group;
    Py_ssize_t group_len;
    const char *keywords[] = {"name", "dims", "user", "group", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#s#s#", (char **) keywords, &name, &name_len, &dims, &dims_len, &user, &user_len, &group, &group_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->createDefinition(std::string(name, name_len), std::string(dims, dims_len), std::string(user, user_len), std::string(group, group_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_deleteDefinition(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *name;
    Py_ssize_t name_len;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->deleteDefinition(std::string(name, name_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_describeDefinition(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *name;
    Py_ssize_t name_len;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->describeDefinition(std::string(name, name_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_translateConstraints(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *dims;
    Py_ssize_t dims_len;
    const char *keywords[] = {"dims", NULL};
    std::vector< std::string > retval;
    Pystd__vector__lt__std__string__gt__ *py_std__vector__lt__std__string__gt__;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &dims, &dims_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->translateConstraints(std::string(dims, dims_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_std__vector__lt__std__string__gt__ = PyObject_New(Pystd__vector__lt__std__string__gt__, &Pystd__vector__lt__std__string__gt___Type);
    py_std__vector__lt__std__string__gt__->obj = new std::vector<std::string>(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__std__string__gt__);
    py_retval = PyType_Type.tp_call((PyObject*)&PyTuple_Type,Py_BuildValue("(O)",py_retval),Py_BuildValue("{}"));
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_locateFile(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *name;
    Py_ssize_t name_len;
    const char *schema = NULL;
    Py_ssize_t schema_len;
    const char *keywords[] = {"name", "schema", NULL};
    std::vector< std::string > retval;
    Pystd__vector__lt__std__string__gt__ *py_std__vector__lt__std__string__gt__;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#", (char **) keywords, &name, &name_len, &schema, &schema_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->locateFile(std::string(name, name_len), (schema ? std::string(schema, schema_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_std__vector__lt__std__string__gt__ = PyObject_New(Pystd__vector__lt__std__string__gt__, &Pystd__vector__lt__std__string__gt___Type);
    py_std__vector__lt__std__string__gt__->obj = new std::vector<std::string>(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__std__string__gt__);
    py_retval = PyType_Type.tp_call((PyObject*)&PyTuple_Type,Py_BuildValue("(O)",py_retval),Py_BuildValue("{}"));
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_getMetadata(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *name;
    Py_ssize_t name_len;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->getMetadata(std::string(name, name_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_dumpStation(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *name;
    Py_ssize_t name_len;
    const char *what = NULL;
    Py_ssize_t what_len;
    const char *keywords[] = {"name", "what", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#", (char **) keywords, &name, &name_len, &what, &what_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->dumpStation(std::string(name, name_len), (what ? std::string(what, what_len) : "all"));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_startProject(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *name;
    Py_ssize_t name_len;
    const char *station;
    Py_ssize_t station_len;
    const char *defname_or_id;
    Py_ssize_t defname_or_id_len;
    const char *user;
    Py_ssize_t user_len;
    const char *group;
    Py_ssize_t group_len;
    const char *keywords[] = {"name", "station", "defname_or_id", "user", "group", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#s#s#s#", (char **) keywords, &name, &name_len, &station, &station_len, &defname_or_id, &defname_or_id_len, &user, &user_len, &group, &group_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->startProject(std::string(name, name_len), std::string(station, station_len), std::string(defname_or_id, defname_or_id_len), std::string(user, user_len), std::string(group, group_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_findProject(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *name;
    Py_ssize_t name_len;
    const char *station;
    Py_ssize_t station_len;
    const char *keywords[] = {"name", "station", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#", (char **) keywords, &name, &name_len, &station, &station_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->findProject(std::string(name, name_len), std::string(station, station_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_establishProcess(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *projecturi;
    Py_ssize_t projecturi_len;
    const char *appname;
    Py_ssize_t appname_len;
    const char *appversion;
    Py_ssize_t appversion_len;
    const char *location;
    Py_ssize_t location_len;
    const char *user;
    Py_ssize_t user_len;
    const char *appfamily = NULL;
    Py_ssize_t appfamily_len;
    const char *description = NULL;
    Py_ssize_t description_len;
    int filelimit = -1;
    const char *schemas = NULL;
    Py_ssize_t schemas_len;
    const char *keywords[] = {"projecturi", "appname", "appversion", "location", "user", "appfamily", "description", "filelimit", "schemas", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#s#s#s#|s#s#is#", (char **) keywords, &projecturi, &projecturi_len, &appname, &appname_len, &appversion, &appversion_len, &location, &location_len, &user, &user_len, &appfamily, &appfamily_len, &description, &description_len, &filelimit, &schemas, &schemas_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->establishProcess(std::string(projecturi, projecturi_len), std::string(appname, appname_len), std::string(appversion, appversion_len), std::string(location, location_len), std::string(user, user_len), (appfamily ? std::string(appfamily, appfamily_len) : ""), (description ? std::string(description, description_len) : ""), filelimit, (schemas ? std::string(schemas, schemas_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_getNextFile(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *projecturi;
    Py_ssize_t projecturi_len;
    const char *processid;
    Py_ssize_t processid_len;
    const char *keywords[] = {"projecturi", "processid", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#", (char **) keywords, &projecturi, &projecturi_len, &processid, &processid_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->getNextFile(std::string(projecturi, projecturi_len), std::string(processid, processid_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_updateFileStatus(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *projecturi;
    Py_ssize_t projecturi_len;
    const char *processid;
    Py_ssize_t processid_len;
    const char *filename;
    Py_ssize_t filename_len;
    const char *status;
    Py_ssize_t status_len;
    const char *keywords[] = {"projecturi", "processid", "filename", "status", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#s#s#", (char **) keywords, &projecturi, &projecturi_len, &processid, &processid_len, &filename, &filename_len, &status, &status_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->updateFileStatus(std::string(projecturi, projecturi_len), std::string(processid, processid_len), std::string(filename, filename_len), std::string(status, status_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_endProcess(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *projecturi;
    Py_ssize_t projecturi_len;
    const char *processid;
    Py_ssize_t processid_len;
    const char *keywords[] = {"projecturi", "processid", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#", (char **) keywords, &projecturi, &projecturi_len, &processid, &processid_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->endProcess(std::string(projecturi, projecturi_len), std::string(processid, processid_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_endProject(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *projecturi;
    Py_ssize_t projecturi_len;
    const char *keywords[] = {"projecturi", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &projecturi, &projecturi_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->endProject(std::string(projecturi, projecturi_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_dumpProject(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *projecturi;
    Py_ssize_t projecturi_len;
    const char *keywords[] = {"projecturi", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &projecturi, &projecturi_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->dumpProject(std::string(projecturi, projecturi_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_setStatus(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *projecturi;
    Py_ssize_t projecturi_len;
    const char *processid;
    Py_ssize_t processid_len;
    const char *status;
    Py_ssize_t status_len;
    const char *keywords[] = {"projecturi", "processid", "status", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#s#", (char **) keywords, &projecturi, &projecturi_len, &processid, &processid_len, &status, &status_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->setStatus(std::string(projecturi, projecturi_len), std::string(processid, processid_len), std::string(status, status_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_cleanup(PyIfdh_nsIfdh *self)
{
    PyObject *py_retval;
    int retval;

    try
    {
        retval = self->obj->cleanup();
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_renameOutput(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *how;
    Py_ssize_t how_len;
    const char *keywords[] = {"how", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &how, &how_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->renameOutput(std::string(how, how_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_mv(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    std::vector<std::string> args_value;
    const char *keywords[] = {"args", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&", (char **) keywords, _wrap_convert_py2c__std__vector__lt___std__string___gt__, &args_value)) {
        return NULL;
    }
    try
    {
        retval = self->obj->mv(args_value);
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_ls(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *loc;
    Py_ssize_t loc_len;
    int recursion_depth;
    const char *force = NULL;
    Py_ssize_t force_len;
    const char *keywords[] = {"loc", "recursion_depth", "force", NULL};
    std::vector< std::string > retval;
    Pystd__vector__lt__std__string__gt__ *py_std__vector__lt__std__string__gt__;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#i|s#", (char **) keywords, &loc, &loc_len, &recursion_depth, &force, &force_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->ls(std::string(loc, loc_len), recursion_depth, (force ? std::string(force, force_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_std__vector__lt__std__string__gt__ = PyObject_New(Pystd__vector__lt__std__string__gt__, &Pystd__vector__lt__std__string__gt___Type);
    py_std__vector__lt__std__string__gt__->obj = new std::vector<std::string>(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__std__string__gt__);
    py_retval = PyType_Type.tp_call((PyObject*)&PyTuple_Type,Py_BuildValue("(O)",py_retval),Py_BuildValue("{}"));
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_mkdir(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *loc;
    Py_ssize_t loc_len;
    const char *force = NULL;
    Py_ssize_t force_len;
    const char *keywords[] = {"loc", "force", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#", (char **) keywords, &loc, &loc_len, &force, &force_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->mkdir(std::string(loc, loc_len), (force ? std::string(force, force_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_rm(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *loc;
    Py_ssize_t loc_len;
    const char *force = NULL;
    Py_ssize_t force_len;
    const char *keywords[] = {"loc", "force", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#", (char **) keywords, &loc, &loc_len, &force, &force_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->rm(std::string(loc, loc_len), (force ? std::string(force, force_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_rmdir(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *loc;
    Py_ssize_t loc_len;
    const char *force = NULL;
    Py_ssize_t force_len;
    const char *keywords[] = {"loc", "force", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#", (char **) keywords, &loc, &loc_len, &force, &force_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->rmdir(std::string(loc, loc_len), (force ? std::string(force, force_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_more(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *loc;
    Py_ssize_t loc_len;
    const char *keywords[] = {"loc", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &loc, &loc_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->more(std::string(loc, loc_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_chmod(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *mode;
    Py_ssize_t mode_len;
    const char *loc;
    Py_ssize_t loc_len;
    const char *force = NULL;
    Py_ssize_t force_len;
    const char *keywords[] = {"mode", "loc", "force", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#|s#", (char **) keywords, &mode, &mode_len, &loc, &loc_len, &force, &force_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->chmod(std::string(mode, mode_len), std::string(loc, loc_len), (force ? std::string(force, force_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_rename(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *loc;
    Py_ssize_t loc_len;
    const char *loc2;
    Py_ssize_t loc2_len;
    const char *force = NULL;
    Py_ssize_t force_len;
    const char *keywords[] = {"loc", "loc2", "force", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#|s#", (char **) keywords, &loc, &loc_len, &loc2, &loc2_len, &force, &force_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->rename(std::string(loc, loc_len), std::string(loc2, loc2_len), (force ? std::string(force, force_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_ll(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *loc;
    Py_ssize_t loc_len;
    int recursion_depth;
    const char *force = NULL;
    Py_ssize_t force_len;
    const char *keywords[] = {"loc", "recursion_depth", "force", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#i|s#", (char **) keywords, &loc, &loc_len, &recursion_depth, &force, &force_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->ll(std::string(loc, loc_len), recursion_depth, (force ? std::string(force, force_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_lss(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *loc;
    Py_ssize_t loc_len;
    int recursion_depth;
    const char *force = NULL;
    Py_ssize_t force_len;
    const char *keywords[] = {"loc", "recursion_depth", "force", NULL};
    std::vector< ifdh_lss_pair > retval;
    Pystd__vector__lt__ifdh_lss_pair__gt__ *py_std__vector__lt__ifdh_lss_pair__gt__;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#i|s#", (char **) keywords, &loc, &loc_len, &recursion_depth, &force, &force_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->lss(std::string(loc, loc_len), recursion_depth, (force ? std::string(force, force_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_std__vector__lt__ifdh_lss_pair__gt__ = PyObject_New(Pystd__vector__lt__ifdh_lss_pair__gt__, &Pystd__vector__lt__ifdh_lss_pair__gt___Type);
    py_std__vector__lt__ifdh_lss_pair__gt__->obj = new std::vector<ifdh_lss_pair>(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__ifdh_lss_pair__gt__);
    py_retval = PyType_Type.tp_call((PyObject*)&PyList_Type,Py_BuildValue("(O)",py_retval),Py_BuildValue("{}"));
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_findMatchingFiles(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    const char *path;
    Py_ssize_t path_len;
    const char *glob;
    Py_ssize_t glob_len;
    const char *keywords[] = {"path", "glob", NULL};
    std::vector< ifdh_lss_pair > retval;
    Pystd__vector__lt__ifdh_lss_pair__gt__ *py_std__vector__lt__ifdh_lss_pair__gt__;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#", (char **) keywords, &path, &path_len, &glob, &glob_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->findMatchingFiles(std::string(path, path_len), std::string(glob, glob_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_std__vector__lt__ifdh_lss_pair__gt__ = PyObject_New(Pystd__vector__lt__ifdh_lss_pair__gt__, &Pystd__vector__lt__ifdh_lss_pair__gt___Type);
    py_std__vector__lt__ifdh_lss_pair__gt__->obj = new std::vector<ifdh_lss_pair>(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__ifdh_lss_pair__gt__);
    py_retval = PyType_Type.tp_call((PyObject*)&PyList_Type,Py_BuildValue("(O)",py_retval),Py_BuildValue("{}"));
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_fetchSharedFiles(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::vector<ifdh_lss_pair> list_value;
    const char *schema = NULL;
    Py_ssize_t schema_len;
    const char *keywords[] = {"list", "schema", NULL};
    std::vector< ifdh_lss_pair > retval;
    Pystd__vector__lt__ifdh_lss_pair__gt__ *py_std__vector__lt__ifdh_lss_pair__gt__;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&|s#", (char **) keywords, _wrap_convert_py2c__std__vector__lt___ifdh_lss_pair___gt__, &list_value, &schema, &schema_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->fetchSharedFiles(list_value, (schema ? std::string(schema, schema_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_std__vector__lt__ifdh_lss_pair__gt__ = PyObject_New(Pystd__vector__lt__ifdh_lss_pair__gt__, &Pystd__vector__lt__ifdh_lss_pair__gt___Type);
    py_std__vector__lt__ifdh_lss_pair__gt__->obj = new std::vector<ifdh_lss_pair>(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__vector__lt__ifdh_lss_pair__gt__);
    py_retval = PyType_Type.tp_call((PyObject*)&PyList_Type,Py_BuildValue("(O)",py_retval),Py_BuildValue("{}"));
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_locateFiles(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::vector<std::string> args_value;
    const char *keywords[] = {"args", NULL};
    std::map< std::string, std::vector< std::string > > retval;
    Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__ *py_std__map__lt__std__string_std__vector__lt__std__string__gt_____gt__;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&", (char **) keywords, _wrap_convert_py2c__std__vector__lt___std__string___gt__, &args_value)) {
        return NULL;
    }
    try
    {
        retval = self->obj->locateFiles(args_value);
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_std__map__lt__std__string_std__vector__lt__std__string__gt_____gt__ = PyObject_New(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__, &Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt___Type);
    py_std__map__lt__std__string_std__vector__lt__std__string__gt_____gt__->obj = new std::map<std::string,std::vector<std::string> >(retval);
    py_retval = Py_BuildValue((char *) "N", py_std__map__lt__std__string_std__vector__lt__std__string__gt_____gt__);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_checksum(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *loc;
    Py_ssize_t loc_len;
    const char *keywords[] = {"loc", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &loc, &loc_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->checksum(std::string(loc, loc_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_mkdir_p(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *loc;
    Py_ssize_t loc_len;
    const char *force = NULL;
    Py_ssize_t force_len;
    int depth = -1;
    const char *keywords[] = {"loc", "force", "depth", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#i", (char **) keywords, &loc, &loc_len, &force, &force_len, &depth)) {
        return NULL;
    }
    try
    {
        retval = self->obj->mkdir_p(std::string(loc, loc_len), (force ? std::string(force, force_len) : ""), depth);
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_getProxy(PyIfdh_nsIfdh *self)
{
    PyObject *py_retval;
    std::string retval;

    try
    {
        retval = self->obj->getProxy();
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_getToken(PyIfdh_nsIfdh *self)
{
    PyObject *py_retval;
    std::string retval;

    try
    {
        retval = self->obj->getToken();
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_declareFile(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *json_metadata;
    Py_ssize_t json_metadata_len;
    const char *keywords[] = {"json_metadata", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &json_metadata, &json_metadata_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->declareFile(std::string(json_metadata, json_metadata_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_modifyMetadata(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *file;
    Py_ssize_t file_len;
    const char *json_metadata;
    Py_ssize_t json_metadata_len;
    const char *keywords[] = {"file", "json_metadata", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#", (char **) keywords, &file, &file_len, &json_metadata, &json_metadata_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->modifyMetadata(std::string(file, file_len), std::string(json_metadata, json_metadata_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_apply(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    std::vector<std::string> args_value;
    const char *keywords[] = {"args", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O&", (char **) keywords, _wrap_convert_py2c__std__vector__lt___std__string___gt__, &args_value)) {
        return NULL;
    }
    try
    {
        retval = self->obj->apply(args_value);
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_getUrl(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *loc;
    Py_ssize_t loc_len;
    const char *force = NULL;
    Py_ssize_t force_len;
    const char *keywords[] = {"loc", "force", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#|s#", (char **) keywords, &loc, &loc_len, &force, &force_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->getUrl(std::string(loc, loc_len), (force ? std::string(force, force_len) : ""));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_getErrorText(PyIfdh_nsIfdh *self)
{
    PyObject *py_retval;
    std::string retval;

    try
    {
        retval = self->obj->getErrorText();
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_takeSnapshot(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *name;
    Py_ssize_t name_len;
    const char *keywords[] = {"name", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &name, &name_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->takeSnapshot(std::string(name, name_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_projectStatus(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    std::string retval;
    const char *projecturi;
    Py_ssize_t projecturi_len;
    const char *keywords[] = {"projecturi", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#", (char **) keywords, &projecturi, &projecturi_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->projectStatus(std::string(projecturi, projecturi_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "s#", (retval).c_str(), (retval).size());
    return py_retval;
}


PyObject *
_wrap_PyIfdh_nsIfdh_addFileLocation(PyIfdh_nsIfdh *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    const char *filename;
    Py_ssize_t filename_len;
    const char *location;
    Py_ssize_t location_len;
    const char *keywords[] = {"filename", "location", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "s#s#", (char **) keywords, &filename, &filename_len, &location, &location_len)) {
        return NULL;
    }
    try
    {
        retval = self->obj->addFileLocation(std::string(filename, filename_len), std::string(location, location_len));
    } catch (std::logic_error const &exc) {
        PyErr_SetString((PyObject *) Pystd__logic_error_Type, exc.what());
        return NULL;
    }
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}

static PyMethodDef PyIfdh_nsIfdh_methods[] = {
    {(char *) "set_debug", (PyCFunction) _wrap_PyIfdh_nsIfdh_set_debug, METH_KEYWORDS|METH_VARARGS, "set_debug(s)\n\ntype: s: std::string" },
    {(char *) "set_base_uri", (PyCFunction) _wrap_PyIfdh_nsIfdh_set_base_uri, METH_KEYWORDS|METH_VARARGS, "set_base_uri(baseuri)\n\ntype: baseuri: std::string" },
    {(char *) "cp", (PyCFunction) _wrap_PyIfdh_nsIfdh_cp, METH_KEYWORDS|METH_VARARGS, "cp(args)\n\ntype: args: std::vector< std::string >" },
    {(char *) "fetchInput", (PyCFunction) _wrap_PyIfdh_nsIfdh_fetchInput, METH_KEYWORDS|METH_VARARGS, "fetchInput(src_uri)\n\ntype: src_uri: std::string" },
    {(char *) "localPath", (PyCFunction) _wrap_PyIfdh_nsIfdh_localPath, METH_KEYWORDS|METH_VARARGS, "localPath(src_uri)\n\ntype: src_uri: std::string" },
    {(char *) "addOutputFile", (PyCFunction) _wrap_PyIfdh_nsIfdh_addOutputFile, METH_KEYWORDS|METH_VARARGS, "addOutputFile(filename)\n\ntype: filename: std::string" },
    {(char *) "copyBackOutput", (PyCFunction) _wrap_PyIfdh_nsIfdh_copyBackOutput, METH_KEYWORDS|METH_VARARGS, "copyBackOutput(dest_dir, hash)\n\ntype: dest_dir: std::string\ntype: hash: int" },
    {(char *) "log", (PyCFunction) _wrap_PyIfdh_nsIfdh_log, METH_KEYWORDS|METH_VARARGS, "log(message)\n\ntype: message: std::string" },
    {(char *) "enterState", (PyCFunction) _wrap_PyIfdh_nsIfdh_enterState, METH_KEYWORDS|METH_VARARGS, "enterState(state)\n\ntype: state: std::string" },
    {(char *) "leaveState", (PyCFunction) _wrap_PyIfdh_nsIfdh_leaveState, METH_KEYWORDS|METH_VARARGS, "leaveState(state)\n\ntype: state: std::string" },
    {(char *) "createDefinition", (PyCFunction) _wrap_PyIfdh_nsIfdh_createDefinition, METH_KEYWORDS|METH_VARARGS, "createDefinition(name, dims, user, group)\n\ntype: name: std::string\ntype: dims: std::string\ntype: user: std::string\ntype: group: std::string" },
    {(char *) "deleteDefinition", (PyCFunction) _wrap_PyIfdh_nsIfdh_deleteDefinition, METH_KEYWORDS|METH_VARARGS, "deleteDefinition(name)\n\ntype: name: std::string" },
    {(char *) "describeDefinition", (PyCFunction) _wrap_PyIfdh_nsIfdh_describeDefinition, METH_KEYWORDS|METH_VARARGS, "describeDefinition(name)\n\ntype: name: std::string" },
    {(char *) "translateConstraints", (PyCFunction) _wrap_PyIfdh_nsIfdh_translateConstraints, METH_KEYWORDS|METH_VARARGS, "translateConstraints(dims)\n\ntype: dims: std::string" },
    {(char *) "locateFile", (PyCFunction) _wrap_PyIfdh_nsIfdh_locateFile, METH_KEYWORDS|METH_VARARGS, "locateFile(name, schema)\n\ntype: name: std::string\ntype: schema: std::string" },
    {(char *) "getMetadata", (PyCFunction) _wrap_PyIfdh_nsIfdh_getMetadata, METH_KEYWORDS|METH_VARARGS, "getMetadata(name)\n\ntype: name: std::string" },
    {(char *) "dumpStation", (PyCFunction) _wrap_PyIfdh_nsIfdh_dumpStation, METH_KEYWORDS|METH_VARARGS, "dumpStation(name, what)\n\ntype: name: std::string\ntype: what: std::string" },
    {(char *) "startProject", (PyCFunction) _wrap_PyIfdh_nsIfdh_startProject, METH_KEYWORDS|METH_VARARGS, "startProject(name, station, defname_or_id, user, group)\n\ntype: name: std::string\ntype: station: std::string\ntype: defname_or_id: std::string\ntype: user: std::string\ntype: group: std::string" },
    {(char *) "findProject", (PyCFunction) _wrap_PyIfdh_nsIfdh_findProject, METH_KEYWORDS|METH_VARARGS, "findProject(name, station)\n\ntype: name: std::string\ntype: station: std::string" },
    {(char *) "establishProcess", (PyCFunction) _wrap_PyIfdh_nsIfdh_establishProcess, METH_KEYWORDS|METH_VARARGS, "establishProcess(projecturi, appname, appversion, location, user, appfamily, description, filelimit, schemas)\n\ntype: projecturi: std::string\ntype: appname: std::string\ntype: appversion: std::string\ntype: location: std::string\ntype: user: std::string\ntype: appfamily: std::string\ntype: description: std::string\ntype: filelimit: int\ntype: schemas: std::string" },
    {(char *) "getNextFile", (PyCFunction) _wrap_PyIfdh_nsIfdh_getNextFile, METH_KEYWORDS|METH_VARARGS, "getNextFile(projecturi, processid)\n\ntype: projecturi: std::string\ntype: processid: std::string" },
    {(char *) "updateFileStatus", (PyCFunction) _wrap_PyIfdh_nsIfdh_updateFileStatus, METH_KEYWORDS|METH_VARARGS, "updateFileStatus(projecturi, processid, filename, status)\n\ntype: projecturi: std::string\ntype: processid: std::string\ntype: filename: std::string\ntype: status: std::string" },
    {(char *) "endProcess", (PyCFunction) _wrap_PyIfdh_nsIfdh_endProcess, METH_KEYWORDS|METH_VARARGS, "endProcess(projecturi, processid)\n\ntype: projecturi: std::string\ntype: processid: std::string" },
    {(char *) "endProject", (PyCFunction) _wrap_PyIfdh_nsIfdh_endProject, METH_KEYWORDS|METH_VARARGS, "endProject(projecturi)\n\ntype: projecturi: std::string" },
    {(char *) "dumpProject", (PyCFunction) _wrap_PyIfdh_nsIfdh_dumpProject, METH_KEYWORDS|METH_VARARGS, "dumpProject(projecturi)\n\ntype: projecturi: std::string" },
    {(char *) "setStatus", (PyCFunction) _wrap_PyIfdh_nsIfdh_setStatus, METH_KEYWORDS|METH_VARARGS, "setStatus(projecturi, processid, status)\n\ntype: projecturi: std::string\ntype: processid: std::string\ntype: status: std::string" },
    {(char *) "cleanup", (PyCFunction) _wrap_PyIfdh_nsIfdh_cleanup, METH_NOARGS, "cleanup()\n\n" },
    {(char *) "renameOutput", (PyCFunction) _wrap_PyIfdh_nsIfdh_renameOutput, METH_KEYWORDS|METH_VARARGS, "renameOutput(how)\n\ntype: how: std::string" },
    {(char *) "mv", (PyCFunction) _wrap_PyIfdh_nsIfdh_mv, METH_KEYWORDS|METH_VARARGS, "mv(args)\n\ntype: args: std::vector< std::string >" },
    {(char *) "ls", (PyCFunction) _wrap_PyIfdh_nsIfdh_ls, METH_KEYWORDS|METH_VARARGS, "ls(loc, recursion_depth, force)\n\ntype: loc: std::string\ntype: recursion_depth: int\ntype: force: std::string" },
    {(char *) "mkdir", (PyCFunction) _wrap_PyIfdh_nsIfdh_mkdir, METH_KEYWORDS|METH_VARARGS, "mkdir(loc, force)\n\ntype: loc: std::string\ntype: force: std::string" },
    {(char *) "rm", (PyCFunction) _wrap_PyIfdh_nsIfdh_rm, METH_KEYWORDS|METH_VARARGS, "rm(loc, force)\n\ntype: loc: std::string\ntype: force: std::string" },
    {(char *) "rmdir", (PyCFunction) _wrap_PyIfdh_nsIfdh_rmdir, METH_KEYWORDS|METH_VARARGS, "rmdir(loc, force)\n\ntype: loc: std::string\ntype: force: std::string" },
    {(char *) "more", (PyCFunction) _wrap_PyIfdh_nsIfdh_more, METH_KEYWORDS|METH_VARARGS, "more(loc)\n\ntype: loc: std::string" },
    {(char *) "chmod", (PyCFunction) _wrap_PyIfdh_nsIfdh_chmod, METH_KEYWORDS|METH_VARARGS, "chmod(mode, loc, force)\n\ntype: mode: std::string\ntype: loc: std::string\ntype: force: std::string" },
    {(char *) "rename", (PyCFunction) _wrap_PyIfdh_nsIfdh_rename, METH_KEYWORDS|METH_VARARGS, "rename(loc, loc2, force)\n\ntype: loc: std::string\ntype: loc2: std::string\ntype: force: std::string" },
    {(char *) "ll", (PyCFunction) _wrap_PyIfdh_nsIfdh_ll, METH_KEYWORDS|METH_VARARGS, "ll(loc, recursion_depth, force)\n\ntype: loc: std::string\ntype: recursion_depth: int\ntype: force: std::string" },
    {(char *) "lss", (PyCFunction) _wrap_PyIfdh_nsIfdh_lss, METH_KEYWORDS|METH_VARARGS, "lss(loc, recursion_depth, force)\n\ntype: loc: std::string\ntype: recursion_depth: int\ntype: force: std::string" },
    {(char *) "findMatchingFiles", (PyCFunction) _wrap_PyIfdh_nsIfdh_findMatchingFiles, METH_KEYWORDS|METH_VARARGS, "findMatchingFiles(path, glob)\n\ntype: path: std::string\ntype: glob: std::string" },
    {(char *) "fetchSharedFiles", (PyCFunction) _wrap_PyIfdh_nsIfdh_fetchSharedFiles, METH_KEYWORDS|METH_VARARGS, "fetchSharedFiles(list, schema)\n\ntype: list: std::vector< ifdh_lss_pair >\ntype: schema: std::string" },
    {(char *) "locateFiles", (PyCFunction) _wrap_PyIfdh_nsIfdh_locateFiles, METH_KEYWORDS|METH_VARARGS, "locateFiles(args)\n\ntype: args: std::vector< std::string >" },
    {(char *) "checksum", (PyCFunction) _wrap_PyIfdh_nsIfdh_checksum, METH_KEYWORDS|METH_VARARGS, "checksum(loc)\n\ntype: loc: std::string" },
    {(char *) "mkdir_p", (PyCFunction) _wrap_PyIfdh_nsIfdh_mkdir_p, METH_KEYWORDS|METH_VARARGS, "mkdir_p(loc, force, depth)\n\ntype: loc: std::string\ntype: force: std::string\ntype: depth: int" },
    {(char *) "getProxy", (PyCFunction) _wrap_PyIfdh_nsIfdh_getProxy, METH_NOARGS, "getProxy()\n\n" },
    {(char *) "getToken", (PyCFunction) _wrap_PyIfdh_nsIfdh_getToken, METH_NOARGS, "getToken()\n\n" },
    {(char *) "declareFile", (PyCFunction) _wrap_PyIfdh_nsIfdh_declareFile, METH_KEYWORDS|METH_VARARGS, "declareFile(json_metadata)\n\ntype: json_metadata: std::string" },
    {(char *) "modifyMetadata", (PyCFunction) _wrap_PyIfdh_nsIfdh_modifyMetadata, METH_KEYWORDS|METH_VARARGS, "modifyMetadata(file, json_metadata)\n\ntype: file: std::string\ntype: json_metadata: std::string" },
    {(char *) "apply", (PyCFunction) _wrap_PyIfdh_nsIfdh_apply, METH_KEYWORDS|METH_VARARGS, "apply(args)\n\ntype: args: std::vector< std::string >" },
    {(char *) "getUrl", (PyCFunction) _wrap_PyIfdh_nsIfdh_getUrl, METH_KEYWORDS|METH_VARARGS, "getUrl(loc, force)\n\ntype: loc: std::string\ntype: force: std::string" },
    {(char *) "getErrorText", (PyCFunction) _wrap_PyIfdh_nsIfdh_getErrorText, METH_NOARGS, "getErrorText()\n\n" },
    {(char *) "takeSnapshot", (PyCFunction) _wrap_PyIfdh_nsIfdh_takeSnapshot, METH_KEYWORDS|METH_VARARGS, "takeSnapshot(name)\n\ntype: name: std::string" },
    {(char *) "projectStatus", (PyCFunction) _wrap_PyIfdh_nsIfdh_projectStatus, METH_KEYWORDS|METH_VARARGS, "projectStatus(projecturi)\n\ntype: projecturi: std::string" },
    {(char *) "addFileLocation", (PyCFunction) _wrap_PyIfdh_nsIfdh_addFileLocation, METH_KEYWORDS|METH_VARARGS, "addFileLocation(filename, location)\n\ntype: filename: std::string\ntype: location: std::string" },
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyIfdh_nsIfdh__tp_dealloc(PyIfdh_nsIfdh *self)
{
        ifdh_ns::ifdh *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    Py_TYPE(self)->tp_free((PyObject*)self);
}

PyTypeObject PyIfdh_nsIfdh_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "ifdh.Ifdh",            /* tp_name */
    sizeof(PyIfdh_nsIfdh),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyIfdh_nsIfdh__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
    NULL,
#else
    (cmpfunc)NULL,           /* tp_compare */
#endif
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    "ifdh(baseuri)",                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyIfdh_nsIfdh_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyIfdh_nsIfdh__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- containers --- */



static void
Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_clear(Pystd__vector__lt__ifdh_lss_pair__gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_traverse(Pystd__vector__lt__ifdh_lss_pair__gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__vector__lt__ifdh_lss_pair__gt____tp_dealloc(Pystd__vector__lt__ifdh_lss_pair__gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_dealloc(Pystd__vector__lt__ifdh_lss_pair__gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__ifdh_lss_pair__gt____tp_iter(Pystd__vector__lt__ifdh_lss_pair__gt__ *self)
{
    Pystd__vector__lt__ifdh_lss_pair__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__ifdh_lss_pair__gt__Iter, &Pystd__vector__lt__ifdh_lss_pair__gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::vector<ifdh_lss_pair>::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_iter(Pystd__vector__lt__ifdh_lss_pair__gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_iternext(Pystd__vector__lt__ifdh_lss_pair__gt__Iter *self)
{
    PyObject *py_retval;
    std::vector<ifdh_lss_pair>::iterator iter;
    PyIfdh_nsIfdh_lss_pair *py_ifdh_lss_pair;

    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_ifdh_lss_pair = PyObject_New(PyIfdh_nsIfdh_lss_pair, &PyIfdh_nsIfdh_lss_pair_Type);
    py_ifdh_lss_pair->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_ifdh_lss_pair->obj = new ifdh_ns::ifdh_lss_pair((*iter));
    py_retval = Py_BuildValue((char *) "N", py_ifdh_lss_pair);
    return py_retval;
}

int _wrap_convert_py2c__ifdh_lss_pair(PyObject *value, ifdh_lss_pair *address)
{
    PyObject *py_retval;
    PyIfdh_nsIfdh_lss_pair *tmp_ifdh_lss_pair;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyIfdh_nsIfdh_lss_pair_Type, &tmp_ifdh_lss_pair)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_ifdh_lss_pair->obj;
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__std__vector__lt___ifdh_lss_pair___gt__(PyObject *arg, std::vector<ifdh_lss_pair> *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__vector__lt__ifdh_lss_pair__gt___Type)) {
        *container = *((Pystd__vector__lt__ifdh_lss_pair__gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            ifdh_lss_pair item;
            if (!_wrap_convert_py2c__ifdh_lss_pair(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else if (PyTuple_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyTuple_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            ifdh_lss_pair item;
            if (!_wrap_convert_py2c__ifdh_lss_pair(PyTuple_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__vector__lt__ifdh_lss_pair__gt__ instance, or a list of ifdh_lss_pair");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__vector__lt__ifdh_lss_pair__gt____tp_init(Pystd__vector__lt__ifdh_lss_pair__gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::vector<ifdh_lss_pair>;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__vector__lt___ifdh_lss_pair___gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__vector__lt__ifdh_lss_pair__gt___Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "ifdh.Std__vector__lt__ifdh_lss_pair__gt__",            /* tp_name */
    sizeof(Pystd__vector__lt__ifdh_lss_pair__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt__ifdh_lss_pair__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
    NULL,
#else
    (cmpfunc)NULL,           /* tp_compare */
#endif
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt__ifdh_lss_pair__gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__vector__lt__ifdh_lss_pair__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__ifdh_lss_pair__gt__Iter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "ifdh.Std__vector__lt__ifdh_lss_pair__gt__Iter",            /* tp_name */
    sizeof(Pystd__vector__lt__ifdh_lss_pair__gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
    NULL,
#else
    (cmpfunc)NULL,           /* tp_compare */
#endif
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__vector__lt__ifdh_lss_pair__gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pystd__vector__lt__std__string__gt__Iter__tp_clear(Pystd__vector__lt__std__string__gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__vector__lt__std__string__gt__Iter__tp_traverse(Pystd__vector__lt__std__string__gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__vector__lt__std__string__gt____tp_dealloc(Pystd__vector__lt__std__string__gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_dealloc(Pystd__vector__lt__std__string__gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__vector__lt__std__string__gt____tp_iter(Pystd__vector__lt__std__string__gt__ *self)
{
    Pystd__vector__lt__std__string__gt__Iter *iter = PyObject_GC_New(Pystd__vector__lt__std__string__gt__Iter, &Pystd__vector__lt__std__string__gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::vector<std::string>::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iter(Pystd__vector__lt__std__string__gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iternext(Pystd__vector__lt__std__string__gt__Iter *self)
{
    PyObject *py_retval;
    std::vector<std::string>::iterator iter;

    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_retval = Py_BuildValue((char *) "s#", ((*iter)).c_str(), ((*iter)).size());
    return py_retval;
}

int _wrap_convert_py2c__std__string(PyObject *value, std::string *address)
{
    PyObject *py_retval;
    const char *retval_ptr;
    Py_ssize_t retval_len;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "s#", &retval_ptr, &retval_len)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = std::string(retval_ptr, retval_len);
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__std__vector__lt___std__string___gt__(PyObject *arg, std::vector<std::string> *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__vector__lt__std__string__gt___Type)) {
        *container = *((Pystd__vector__lt__std__string__gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            std::string item;
            if (!_wrap_convert_py2c__std__string(PyList_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else if (PyTuple_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyTuple_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            std::string item;
            if (!_wrap_convert_py2c__std__string(PyTuple_GET_ITEM(arg, i), &item)) {
                return 0;
            }
            container->push_back(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__vector__lt__std__string__gt__ instance, or a list of std::string");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__vector__lt__std__string__gt____tp_init(Pystd__vector__lt__std__string__gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::vector<std::string>;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__vector__lt___std__string___gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__vector__lt__std__string__gt___Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "ifdh.Std__vector__lt__std__string__gt__",            /* tp_name */
    sizeof(Pystd__vector__lt__std__string__gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt__std__string__gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
    NULL,
#else
    (cmpfunc)NULL,           /* tp_compare */
#endif
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt__std__string__gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__vector__lt__std__string__gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__vector__lt__std__string__gt__Iter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "ifdh.Std__vector__lt__std__string__gt__Iter",            /* tp_name */
    sizeof(Pystd__vector__lt__std__string__gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
    NULL,
#else
    (cmpfunc)NULL,           /* tp_compare */
#endif
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__vector__lt__std__string__gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__vector__lt__std__string__gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__vector__lt__std__string__gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




static void
Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_clear(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

}


static int
Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_traverse(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter *self, visitproc visit, void *arg)
{
    Py_VISIT((PyObject *) self->container);
    return 0;
}


static void
_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt____tp_dealloc(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__ *self)
{
    delete self->obj;
    self->obj = NULL;

    Py_TYPE(self)->tp_free((PyObject*)self);
}


static void
_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_dealloc(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter *self)
{
    Py_CLEAR(self->container);
    delete self->iterator;
    self->iterator = NULL;

    Py_TYPE(self)->tp_free((PyObject*)self);
}


static PyObject*
_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt____tp_iter(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__ *self)
{
    Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter *iter = PyObject_GC_New(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter, &Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter_Type);
    Py_INCREF(self);
    iter->container = self;
    iter->iterator = new std::map<std::string,std::vector<std::string> >::iterator(self->obj->begin());
    return (PyObject*) iter;
}


static PyObject*
_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_iter(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter *self)
{
    Py_INCREF(self);
    return (PyObject*) self;
}

static PyObject* _wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_iternext(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter *self)
{
    PyObject *py_retval;
    std::map<std::string,std::vector<std::string> >::iterator iter;
    std::vector< std::string > retval;
    Pystd__vector__lt__std__string__gt__ *py_std__vector__lt__std__string__gt__;

    iter = *self->iterator;
    if (iter == self->container->obj->end()) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    ++(*self->iterator);
    py_std__vector__lt__std__string__gt__ = PyObject_New(Pystd__vector__lt__std__string__gt__, &Pystd__vector__lt__std__string__gt___Type);
    py_std__vector__lt__std__string__gt__->obj = new std::vector<std::string>(iter->second);
    py_retval = Py_BuildValue((char *) "(s#,N)", (iter->first).c_str(), (iter->first).size(), py_std__vector__lt__std__string__gt__);
    return py_retval;
}

int _wrap_convert_py2c__std__map__lt___std__string__std__vector__lt___std__string___gt_____gt__(PyObject *arg, std::map<std::string,std::vector<std::string> > *container)
{
    if (PyObject_IsInstance(arg, (PyObject*) &Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt___Type)) {
        *container = *((Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__*)arg)->obj;
    } else if (PyList_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyList_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            PyObject *tup = PyList_GET_ITEM(arg, i);
            if (!PyTuple_Check(tup) || PyTuple_Size(tup) != 2) {
                PyErr_SetString(PyExc_TypeError, "items must be tuples with two elements");
                return 0;
            }
            std::pair< std::string, std::vector< std::string > > item;
            if (!_wrap_convert_py2c__std__string(PyTuple_GET_ITEM(tup, 0), &item.first)) {
                return 0;
            }
            if (!_wrap_convert_py2c__std__vector__lt___std__string___gt__(PyTuple_GET_ITEM(tup, 1), &item.second)) {
                return 0;
            }
            container->insert(item);
        }
    } else if (PyTuple_Check(arg)) {
        container->clear();
        Py_ssize_t size = PyTuple_Size(arg);
        for (Py_ssize_t i = 0; i < size; i++) {
            PyObject *tup = PyTuple_GET_ITEM(arg, i);
            if (!PyTuple_Check(tup) || PyTuple_Size(tup) != 2) {
                PyErr_SetString(PyExc_TypeError, "items must be tuples with two elements");
                return 0;
            }
            std::pair< std::string, std::vector< std::string > > item;
            if (!_wrap_convert_py2c__std__string(PyTuple_GET_ITEM(tup, 0), &item.first)) {
                return 0;
            }
            if (!_wrap_convert_py2c__std__vector__lt___std__string___gt__(PyTuple_GET_ITEM(tup, 1), &item.second)) {
                return 0;
            }
            container->insert(item);
        }
    } else {
        PyErr_SetString(PyExc_TypeError, "parameter must be None, a Std__map__lt__std__string_std__vector__lt__std__string__gt_____gt__ instance, or a list of std::vector< std::string >");
        return 0;
    }
    return 1;
}


static int
_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt____tp_init(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__ *self, PyObject *args, PyObject *kwargs)
{
    const char *keywords[] = {"arg", NULL};
    PyObject *arg = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "|O", (char **) keywords, &arg)) {
        return -1;
    }

    self->obj = new std::map<std::string,std::vector<std::string> >;

    if (arg == NULL)
        return 0;

    if (!_wrap_convert_py2c__std__map__lt___std__string__std__vector__lt___std__string___gt_____gt__(arg, self->obj)) {
        delete self->obj;
        self->obj = NULL;
        return -1;
    }
    return 0;
}

PyTypeObject Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt___Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "ifdh.Std__map__lt__std__string_std__vector__lt__std__string__gt_____gt__",            /* tp_name */
    sizeof(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt____tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
    NULL,
#else
    (cmpfunc)NULL,           /* tp_compare */
#endif
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt____tp_iter,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt____tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};

PyTypeObject Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    (char *) "ifdh.Std__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter",            /* tp_name */
    sizeof(Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
#if PY_MAJOR_VERSION >= 3
    NULL,
#else
    (cmpfunc)NULL,           /* tp_compare */
#endif
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)NULL,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_traverse,     /* tp_traverse */
    (inquiry)Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_clear,             /* tp_clear */
    (richcmpfunc)NULL,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_iter,          /* tp_iter */
    (iternextfunc)_wrap_Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter__tp_iternext,     /* tp_iternext */
    (struct PyMethodDef*)NULL, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    NULL,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)NULL,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};


/* --- exceptions --- */


PyTypeObject *Pystd__logic_error_Type;

#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef ifdh_moduledef = {
    PyModuleDef_HEAD_INIT,
    "ifdh",
    NULL,
    -1,
    ifdh_functions,
};
#endif


#if PY_VERSION_HEX >= 0x03000000
    #define MOD_ERROR NULL
    #define MOD_INIT(name) PyObject* PyInit_##name(void)
    #define MOD_RETURN(val) val
#else
    #define MOD_ERROR
    #define MOD_INIT(name) void init##name(void)
    #define MOD_RETURN(val)
#endif
#if defined(__cplusplus)
extern "C"
#endif
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__ ((visibility("default")))
#endif


MOD_INIT(ifdh)
{
    PyObject *m;
    #if PY_VERSION_HEX >= 0x03000000
    m = PyModule_Create(&ifdh_moduledef);
    #else
    m = Py_InitModule3((char *) "ifdh", ifdh_functions, NULL);
    #endif
    if (m == NULL) {
        return MOD_ERROR;
    }
    /* Register the 'ifdh_ns::ifdh_lss_pair' class */
    if (PyType_Ready(&PyIfdh_nsIfdh_lss_pair_Type)) {
        return MOD_ERROR;
    }
    PyModule_AddObject(m, (char *) "ifdh_lss_pair", (PyObject *) &PyIfdh_nsIfdh_lss_pair_Type);
    /* Register the 'ifdh_ns::ifdh' class */
    if (PyType_Ready(&PyIfdh_nsIfdh_Type)) {
        return MOD_ERROR;
    }
    PyModule_AddObject(m, (char *) "ifdh", (PyObject *) &PyIfdh_nsIfdh_Type);
    /* Register the 'std::vector<ifdh_lss_pair>' class */
    if (PyType_Ready(&Pystd__vector__lt__ifdh_lss_pair__gt___Type)) {
        return MOD_ERROR;
    }
    if (PyType_Ready(&Pystd__vector__lt__ifdh_lss_pair__gt__Iter_Type)) {
        return MOD_ERROR;
    }
    PyModule_AddObject(m, (char *) "Std__vector__lt__ifdh_lss_pair__gt__", (PyObject *) &Pystd__vector__lt__ifdh_lss_pair__gt___Type);
    PyModule_AddObject(m, (char *) "Std__vector__lt__ifdh_lss_pair__gt__Iter", (PyObject *) &Pystd__vector__lt__ifdh_lss_pair__gt__Iter_Type);
    /* Register the 'std::vector<std::string>' class */
    if (PyType_Ready(&Pystd__vector__lt__std__string__gt___Type)) {
        return MOD_ERROR;
    }
    if (PyType_Ready(&Pystd__vector__lt__std__string__gt__Iter_Type)) {
        return MOD_ERROR;
    }
    PyModule_AddObject(m, (char *) "Std__vector__lt__std__string__gt__", (PyObject *) &Pystd__vector__lt__std__string__gt___Type);
    PyModule_AddObject(m, (char *) "Std__vector__lt__std__string__gt__Iter", (PyObject *) &Pystd__vector__lt__std__string__gt__Iter_Type);
    /* Register the 'std::map<std::string,std::vector<std::string> >' class */
    if (PyType_Ready(&Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt___Type)) {
        return MOD_ERROR;
    }
    if (PyType_Ready(&Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter_Type)) {
        return MOD_ERROR;
    }
    PyModule_AddObject(m, (char *) "Std__map__lt__std__string_std__vector__lt__std__string__gt_____gt__", (PyObject *) &Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt___Type);
    PyModule_AddObject(m, (char *) "Std__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter", (PyObject *) &Pystd__map__lt__std__string_std__vector__lt__std__string__gt_____gt__Iter_Type);
    /* Register the 'std::logic_error' exception */
    if ((Pystd__logic_error_Type = (PyTypeObject*) PyErr_NewException((char*)"ifdh.logic_error", NULL, NULL)) == NULL) {
        return MOD_ERROR;
    }
    Py_INCREF((PyObject *) Pystd__logic_error_Type);
    PyModule_AddObject(m, (char *) "logic_error", (PyObject *) Pystd__logic_error_Type);
    return MOD_RETURN(m);
}
